#!/usr/bin/env python3

import socket
import os
import time
from collections import deque
import sys
from ray.core.generated.common_pb2 import ExperimentalCreateProcessRequest, ExperimentalCreateProcessReply


def main():
    listen()

def listen():
  if os.path.exists("/tmp/socket_test.s"):
    os.remove("/tmp/socket_test.s")
  
  server = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
  server.bind("/tmp/socket_test.s")
  
  while True:
    server.listen(1)
    print('listening')
  
    conn, addr = server.accept()
    print(f'accepted {addr}')
    all_recv = b''
    while True:
      received = conn.recv(1024)
      if not received:
        break
      all_recv += received

    req = ExperimentalCreateProcessRequest()
    req.ParseFromString(all_recv)
    print(req)

    reply = ExperimentalCreateProcessReply()
    reply.success = True
    reply_serialized = reply.SerializeToString()

    child_pid = spawn(req.argv_list, req.environ_map, req.preload_import_list)

    # TODO
    #conn.send(reply_serialized)
    #print('sent response')
    conn.close()

"""
This will call exec to create a clean process per runtime environment.
https://github.com/ray-project/ray/blob/master/python/ray/_private/workers/setup_worker.py
Exec call https://github.com/ray-project/ray/blob/master/python/ray/_private/runtime_env/context.py#L52

We need to create a forkserver per runtime environment.
Also, preload_import_list needs to move to forkserver creation time.

TODO find out how PID is known to Raylet
"""
def spawn(argv, environ_map, preload_import_list):
    print(argv)
    print(environ_map)
    print(preload_import_list)
    
    return -1

if __name__ == '__main__':
    sys.exit(main())
